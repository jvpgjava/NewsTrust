import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import mammoth from 'mammoth';
import { createWorker } from 'tesseract.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

class FileProcessor {
    constructor() {
        console.log('üîß FileProcessor v4.0 - OCR otimizado para Vercel');
        // No Vercel, n√£o criar pasta de uploads
        if (process.env.NODE_ENV === 'production' && process.env.VERCEL) {
            this.uploadDir = null; // N√£o usar uploads no Vercel
        } else {
            this.uploadDir = path.join(__dirname, '../uploads');
            this.ensureUploadDir();
        }
        
        // Worker reutiliz√°vel para OCR
        this.worker = null;
    }

    ensureUploadDir() {
        if (this.uploadDir && !fs.existsSync(this.uploadDir)) {
            fs.mkdirSync(this.uploadDir, { recursive: true });
        }
    }

    async getWorker() {
        if (!this.worker) {
            try {
                console.log('üîÑ Inicializando worker OCR...');
                
                // No Vercel, usar configura√ß√£o mais simples
                const options = process.env.VERCEL ? {
                    logger: m => {
                        if (m.status === 'loading tesseract core' || m.status === 'initializing tesseract' || m.status === 'loading language traineddata') {
                            console.log(`üì¶ ${m.status}... ${m.progress ? Math.round(m.progress * 100) + '%' : ''}`);
                        }
                    }
                } : {
                    logger: m => {
                        if (m.status === 'loading tesseract core' || m.status === 'initializing tesseract' || m.status === 'loading language traineddata') {
                            console.log(`üì¶ ${m.status}... ${m.progress ? Math.round(m.progress * 100) + '%' : ''}`);
                        }
                    }
                };
                
                this.worker = await createWorker('por+eng', 1, options);
                console.log('‚úÖ Worker OCR pronto!');
            } catch (error) {
                console.error('‚ùå Erro ao inicializar worker OCR:', error);
                throw new Error('Falha ao inicializar OCR. Use TXT ou DOCX para an√°lise completa.');
            }
        }
        return this.worker;
    }

    async processFile(buffer, mimetype, originalName) {
        try {
            let content = '';
            let fileInfo = {
                name: originalName,
                type: mimetype,
                size: buffer.length,
                processedAt: new Date().toISOString()
            };

            if (mimetype === 'text/plain') {
                content = await this.processTextBuffer(buffer);
            } else if (mimetype === 'application/pdf') {
                content = await this.processPdfBuffer(buffer);
            } else if (mimetype === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
                content = await this.processDocxBuffer(buffer);
            } else if (this.isImageType(mimetype)) {
                content = await this.processImageBuffer(buffer, mimetype);
            } else {
                throw new Error(`Tipo de arquivo n√£o suportado: ${mimetype}`);
            }

            // Extrair t√≠tulo do nome do arquivo
            const title = this.extractTitleFromFilename(originalName);

            return {
                title,
                content: content.trim(),
                fileInfo
            };
        } catch (error) {
            throw new Error(`Erro ao processar arquivo: ${error.message}`);
        }
    }

    async processTextBuffer(buffer) {
        return buffer.toString('utf-8');
    }

    async processPdfBuffer(buffer) {
        try {
            console.log('üìÑ Tentando processar PDF com OCR...', {
                bufferSize: buffer.length
            });
            
            // No ambiente Vercel, usar fallback mais simples
            if (process.env.VERCEL) {
                console.log('üåê Ambiente Vercel detectado - usando fallback para PDF');
                return `[PDF] - Para an√°lise completa, converta o PDF para PNG/JPG ou use DOCX/TXT. Tamanho do arquivo: ${Math.round(buffer.length / 1024)}KB.`;
            }
            
            // Obter worker reutiliz√°vel
            const worker = await this.getWorker();
            
            console.log('üñºÔ∏è Usando OCR (Tesseract) para extrair texto do PDF...');
            
            const { data: { text } } = await worker.recognize(buffer, {
                rotateAuto: true
            });
            
            const extractedText = text.trim();
            console.log(`‚úÖ Texto extra√≠do: ${extractedText.length} caracteres`);
            
            if (extractedText.length < 10) {
                return `[PDF] - Texto n√£o detectado. Para an√°lise completa, converta o PDF para PNG/JPG ou use DOCX/TXT.`;
            }
            
            return extractedText;
            
        } catch (error) {
            console.error('‚ùå Erro ao processar PDF:', error.message);
            return `[PDF] - Erro no processamento. Para an√°lise completa, converta o PDF para PNG/JPG ou use DOCX/TXT.`;
        }
    }

    async processDocxBuffer(buffer) {
        try {
            const result = await mammoth.extractRawText({ buffer });
            return result.value;
        } catch (error) {
            throw new Error(`Erro ao processar DOCX: ${error.message}`);
        }
    }

    async processImageBuffer(buffer, mimetype) {
        try {
            console.log('üîç Iniciando OCR para extrair texto da imagem...', {
                mimetype,
                bufferSize: buffer.length
            });
            
            // No ambiente Vercel, usar fallback mais simples
            if (process.env.VERCEL) {
                console.log('üåê Ambiente Vercel detectado - usando fallback para imagem');
                return `[IMAGEM ${this.getImageTypeName(mimetype).toUpperCase()}] - Para an√°lise completa, use TXT ou DOCX. Tamanho: ${Math.round(buffer.length / 1024)}KB.`;
            }
            
            // Obter worker reutiliz√°vel
            const worker = await this.getWorker();
            
            const { data: { text } } = await worker.recognize(buffer, {
                rotateAuto: true
            });
            
            const extractedText = text.trim();
            console.log(`‚úÖ OCR conclu√≠do. Texto extra√≠do: ${extractedText.length} caracteres`);
            
            if (extractedText.length === 0) {
                return `[IMAGEM ${this.getImageTypeName(mimetype).toUpperCase()}] - Nenhum texto detectado na imagem.`;
            }
            
            return extractedText;
            
        } catch (error) {
            console.error('‚ùå Erro no processamento de imagem:', error);
            return `[IMAGEM ${this.getImageTypeName(mimetype).toUpperCase()}] - Erro no processamento. Para an√°lise completa, use TXT ou DOCX.`;
        }
    }

    isValidFileType(mimetype) {
        const allowedTypes = [
            'text/plain',
            'application/pdf',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
            // Tipos de imagem
            'image/jpeg',
            'image/jpg',
            'image/png',
            'image/gif',
            'image/bmp',
            'image/webp',
            'image/tiff'
        ];
        return allowedTypes.includes(mimetype);
    }

    isValidFileSize(size) {
        const maxSize = 5 * 1024 * 1024; // 5MB
        return size <= maxSize;
    }

    extractTitleFromFilename(filename) {
        // Remove extens√£o e substitui underscores/h√≠fens por espa√ßos
        const nameWithoutExt = path.parse(filename).name;
        return nameWithoutExt
            .replace(/[_-]/g, ' ')
            .replace(/\b\w/g, l => l.toUpperCase());
    }

    isImageType(mimetype) {
        return mimetype.startsWith('image/');
    }

    getImageTypeName(mimetype) {
        const imageTypes = {
            'image/jpeg': 'JPEG',
            'image/jpg': 'JPEG',
            'image/png': 'PNG',
            'image/gif': 'GIF',
            'image/bmp': 'BMP',
            'image/webp': 'WEBP',
            'image/tiff': 'TIFF'
        };
        return imageTypes[mimetype] || 'IMAGEM';
    }
}

export default new FileProcessor();
